первая задача на динамическое программирование
рассмотрим отрезок с i по j
тогда первый случай, элементы i и j равны, то есть s[i]=s[j].
возникает вопрос, какие палиндромы нужно добавить. во-первых это все палиндромы с i по j-1 и с i+1 по j, т.е dp[i][j-1]+dp[i+1][j].тогда все палиндромы которые есть в отрезке с i+1по j-1 будут дважды повторятся, значит надо отнять это кол-во, что приводит к dp[i][j-1]+dp[i+1][j]-dp[i+1][j-1]. до этого мы посчитали все палиндромы которые либо начинались на i-тый, либо заканчивались на j-тый, либо не начинались на i-тый и не заканчивались на j-тый, теперь надо посчитать, те палиндромы которые и начинаются на i-тый и заканчиваются на j-тый: тогда возьмем s[i]+...+s[j] если ... это палиндром то полученная строка тоже будет палиндромом, значит кол-во таких палиндромов dp[i+1][j-1], это как раз все такие палинромы которые можно вставить между элементами s[i] и s[j], но еще s[i]+s[j] тоже палиндром значит кол-во таких будет dp[i+1][j-1]+1. а всего кол-во палиндромов для первого случая будет dp[i][j-1]+dp[i+1][j]-dp[i+1][j-1]+dp[i+1][j-1]+1 что равно dp[i][j-1]+dp[i+1][j]+1
второй случай s[i]!=s[j]: тогда нам надо только посчитать все палиндромы которые либо начинаются на i-тый, либо заканчиваются на j-тый, либо не начинаются на i-тый и не заканчиваются на j-тый их кол-во мы уже считали и это dp[i+1][j]+dp[i][j-1]-dp[i+1][j-1]
заполняем массив dp в порядке увеличения отрезка. ответ будет лежать в dp[1][n]